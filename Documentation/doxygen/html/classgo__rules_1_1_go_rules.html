<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Application of monte carlo search techniques on board games through go.: go_rules.GoRules Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Application of monte carlo search techniques on board games through go.<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>go_rules</b></li><li class="navelem"><a class="el" href="classgo__rules_1_1_go_rules.html">GoRules</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classgo__rules_1_1_go_rules-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">go_rules.GoRules Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9daaf047748093f85466f108ed413dd5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#a9daaf047748093f85466f108ed413dd5">__init__</a> (self, piece_matrix, size)</td></tr>
<tr class="separator:a9daaf047748093f85466f108ed413dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee1d9a43fa27d7a39b82c2bc29a0817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpiece_1_1_piece.html">Piece</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#aaee1d9a43fa27d7a39b82c2bc29a0817">get_piece_at_position</a> (self, int row, int col)</td></tr>
<tr class="separator:aaee1d9a43fa27d7a39b82c2bc29a0817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d9d79cd7cb2a295bf571bbe512fc0"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ab71d9d79cd7cb2a295bf571bbe512fc0">get_adjacent_of_colour</a> (self, int row, int col, <a class="el" href="classcolours_1_1_colour.html">Colour</a> colour)</td></tr>
<tr class="separator:ab71d9d79cd7cb2a295bf571bbe512fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af704796aa1a51d4f0b25f60fe54508ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#af704796aa1a51d4f0b25f60fe54508ad">is_move_legal</a> (self, tuple position, <a class="el" href="classcolours_1_1_colour.html">Colour</a> colour, <a class="el" href="classplayerturn_1_1_player_turn.html">PlayerTurn</a> current_colour)</td></tr>
<tr class="separator:af704796aa1a51d4f0b25f60fe54508ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9468a998bf06bc173c376c642c6a0e"><td class="memItemLeft" align="right" valign="top">set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#a1d9468a998bf06bc173c376c642c6a0e">get_liberties_for_group</a> (self, list group)</td></tr>
<tr class="separator:a1d9468a998bf06bc173c376c642c6a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef671133b33a261fc44fd7381b1c538f"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#aef671133b33a261fc44fd7381b1c538f">create_group_from_piece</a> (self, int row, int col, list group, <a class="el" href="classcolours_1_1_colour.html">Colour</a> colour)</td></tr>
<tr class="separator:aef671133b33a261fc44fd7381b1c538f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16fadb78a41d947f9aecc8d92565c5f"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ac16fadb78a41d947f9aecc8d92565c5f">get_all_groups_on_board</a> (self, piece_matrix)</td></tr>
<tr class="separator:ac16fadb78a41d947f9aecc8d92565c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8812ebe2f46ea5dabb15012138805a6"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ab8812ebe2f46ea5dabb15012138805a6">get_liberties_for_group</a> (self, group)</td></tr>
<tr class="separator:ab8812ebe2f46ea5dabb15012138805a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617333cd9008615dc4e47165133f0e43"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#a617333cd9008615dc4e47165133f0e43">get_legal_spots_to_play</a> (self, piece_matrix)</td></tr>
<tr class="separator:a617333cd9008615dc4e47165133f0e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69317b71d092cd0f364e40c14eda49a3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#a69317b71d092cd0f364e40c14eda49a3">next_state</a> (self, piece_matrix, position)</td></tr>
<tr class="separator:a69317b71d092cd0f364e40c14eda49a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e91e0711894c1b78bd69180b835996"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ac5e91e0711894c1b78bd69180b835996">remove_captured_groups_from_board</a> (self, piece_matrix)</td></tr>
<tr class="separator:ac5e91e0711894c1b78bd69180b835996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bb26e3a1edf7fcf79f99909eceb7ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ac5bb26e3a1edf7fcf79f99909eceb7ee">get_number_of_black_pieces</a> (self, piece_matrix)</td></tr>
<tr class="separator:ac5bb26e3a1edf7fcf79f99909eceb7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79efd9d2593b4686bccc7a47db17a76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ad79efd9d2593b4686bccc7a47db17a76">get_number_of_white_pieces</a> (self, piece_matrix)</td></tr>
<tr class="separator:ad79efd9d2593b4686bccc7a47db17a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8eeb1536159dcb0fa1d8c4298eae689"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ad8eeb1536159dcb0fa1d8c4298eae689">get_black_territory</a> (self, piece_matrix)</td></tr>
<tr class="separator:ad8eeb1536159dcb0fa1d8c4298eae689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab9e04a9c181f5bbd9f8a129135ebc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#a00ab9e04a9c181f5bbd9f8a129135ebc">get_white_territory</a> (self, piece_matrix)</td></tr>
<tr class="separator:a00ab9e04a9c181f5bbd9f8a129135ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac787ab5125c90e778d5486b1a2f323d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ac787ab5125c90e778d5486b1a2f323d1">score</a> (self, piece_matrix)</td></tr>
<tr class="separator:ac787ab5125c90e778d5486b1a2f323d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37549f7e9d885dc98eebfc1ce883fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#ae37549f7e9d885dc98eebfc1ce883fbb">get_territory_for_black</a> (self, piece_matrix)</td></tr>
<tr class="separator:ae37549f7e9d885dc98eebfc1ce883fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d485c4c0ba152ec1c223038dd3bba15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgo__rules_1_1_go_rules.html#a4d485c4c0ba152ec1c223038dd3bba15">get_territory_for_white</a> (self, piece_matrix)</td></tr>
<tr class="separator:a4d485c4c0ba152ec1c223038dd3bba15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afbf696b001386aa6f406f5b30979e002"><td class="memItemLeft" align="right" valign="top"><a id="afbf696b001386aa6f406f5b30979e002" name="afbf696b001386aa6f406f5b30979e002"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="separator:afbf696b001386aa6f406f5b30979e002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190d0b2eb5b4fde7980cf0f51901c247"><td class="memItemLeft" align="right" valign="top"><a id="a190d0b2eb5b4fde7980cf0f51901c247" name="a190d0b2eb5b4fde7980cf0f51901c247"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>piece_matrix</b></td></tr>
<tr class="separator:a190d0b2eb5b4fde7980cf0f51901c247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493ca017d12b92a482e56d66f5df8404"><td class="memItemLeft" align="right" valign="top"><a id="a493ca017d12b92a482e56d66f5df8404" name="a493ca017d12b92a482e56d66f5df8404"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>current_colour</b></td></tr>
<tr class="separator:a493ca017d12b92a482e56d66f5df8404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfac2827f541c36c4b62d0b6384e073"><td class="memItemLeft" align="right" valign="top"><a id="aadfac2827f541c36c4b62d0b6384e073" name="aadfac2827f541c36c4b62d0b6384e073"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>possible_ko</b></td></tr>
<tr class="separator:aadfac2827f541c36c4b62d0b6384e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061c78794398216c3c77b1acfe555f6"><td class="memItemLeft" align="right" valign="top"><a id="a0061c78794398216c3c77b1acfe555f6" name="a0061c78794398216c3c77b1acfe555f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ko_position</b></td></tr>
<tr class="separator:a0061c78794398216c3c77b1acfe555f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc402f0c3cd88e66fa5ffb58988856d"><td class="memItemLeft" align="right" valign="top"><a id="a9cc402f0c3cd88e66fa5ffb58988856d" name="a9cc402f0c3cd88e66fa5ffb58988856d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>killed_groups</b></td></tr>
<tr class="separator:a9cc402f0c3cd88e66fa5ffb58988856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8a634b34a06228bb7498592ac661a7"><td class="memItemLeft" align="right" valign="top"><a id="a0c8a634b34a06228bb7498592ac661a7" name="a0c8a634b34a06228bb7498592ac661a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>opposite_colour</b></td></tr>
<tr class="separator:a0c8a634b34a06228bb7498592ac661a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This is a class that is used to check for different rules in the game such as checking if a move is legal that can be
used to check if the move that an ai or player did is able to be done on the board. Is also used for capturing any
groups on the board that has no liberties left as well as evaluating a board position depending on the territory for
each colour which is used by the ai to make decisions on what moves to pick
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9daaf047748093f85466f108ed413dd5" name="a9daaf047748093f85466f108ed413dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daaf047748093f85466f108ed413dd5">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def go_rules.GoRules.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets up the rules for a certain state as well as size of board
:param piece_matrix: state that we want to create a rules class for
:param size: how big the board is for this state
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aef671133b33a261fc44fd7381b1c538f" name="aef671133b33a261fc44fd7381b1c538f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef671133b33a261fc44fd7381b1c538f">&#9670;&nbsp;</a></span>create_group_from_piece()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list go_rules.GoRules.create_group_from_piece </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolours_1_1_colour.html">Colour</a>&#160;</td>
          <td class="paramname"><em>colour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">takes in a particular piece along with its colour so that a group is able to be created for the piece with all
of the other pieces surrounding it that are of the same colour. A piece has to be connected either
horizontally or vertically to be added to the same group as another piece. This function is recursively called
so that if there are several pieces in a row or that connect horizontally and vertically these pieces will still
be added to the same group of pieces.
:param row: row of the piece that you are checking
:param col: col of the piece that you are checking
:param group: current group that you have found for this piece
:param colour: colour of piece that you are adding to this group. You only want to add pieces of the same colour
to the group
:return: A list representing all of the pieces in the group
</pre> 
</div>
</div>
<a id="ab71d9d79cd7cb2a295bf571bbe512fc0" name="ab71d9d79cd7cb2a295bf571bbe512fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71d9d79cd7cb2a295bf571bbe512fc0">&#9670;&nbsp;</a></span>get_adjacent_of_colour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list go_rules.GoRules.get_adjacent_of_colour </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolours_1_1_colour.html">Colour</a>&#160;</td>
          <td class="paramname"><em>colour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds all of the adjacent pieces of the same colour for a specific piece on the board
:param row: row of the piece to be checked
:param col: col of the piece to be checked
:param colour: colour of the piece to be checked
:return: a list of all the pieces beside this piece that are the same colour. Returns an empty list if there is no
piece of the same colour beside it
</pre> 
</div>
</div>
<a id="ac16fadb78a41d947f9aecc8d92565c5f" name="ac16fadb78a41d947f9aecc8d92565c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16fadb78a41d947f9aecc8d92565c5f">&#9670;&nbsp;</a></span>get_all_groups_on_board()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list go_rules.GoRules.get_all_groups_on_board </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets all of the groups on the board and then returns all of these groups as a list of lists. Uses another list
of bools to keep track of what spots on the board it has already checked so that pieces and groups are not
returned more than once from the function. Uses a helper function to create all of the groups once it finds
either a black or white piece on the board. Does not create groups for empty spots or Ko.
:param piece_matrix: The state that you want to get all of the groups for
:return: A list of all of the groups which are another list of all of the Pieces in the group
</pre> 
</div>
</div>
<a id="ad8eeb1536159dcb0fa1d8c4298eae689" name="ad8eeb1536159dcb0fa1d8c4298eae689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8eeb1536159dcb0fa1d8c4298eae689">&#9670;&nbsp;</a></span>get_black_territory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int go_rules.GoRules.get_black_territory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Defining black territory as any empty spot that is fully surrounded by only black
</pre> 
</div>
</div>
<a id="a617333cd9008615dc4e47165133f0e43" name="a617333cd9008615dc4e47165133f0e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617333cd9008615dc4e47165133f0e43">&#9670;&nbsp;</a></span>get_legal_spots_to_play()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list go_rules.GoRules.get_legal_spots_to_play </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">goes through the state given and finds all spots that are able to be played at. It is possible to play at a
position if there is no pieces already there, there isn't Ko at the spot and there is at least one liberty for
that position
:param piece_matrix: state that you want to get all possible moves for
:return: returns a list of all possible positions to play at for this position
</pre> 
</div>
</div>
<a id="ab8812ebe2f46ea5dabb15012138805a6" name="ab8812ebe2f46ea5dabb15012138805a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8812ebe2f46ea5dabb15012138805a6">&#9670;&nbsp;</a></span>get_liberties_for_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list go_rules.GoRules.get_liberties_for_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Takes in a group and finds all adjacent spots that don't have any pieces on them as well as any spots with ko
and adds these to the list of their liberties.
Also momentarily changes these to a set before changing it back to a list so that the function does not
count liberties more than once.
:param group: the group that you want to get all of the liberties for.
:return: A list of all the liberties for this group. Will return a group of length of 0 if they have no
liberties.
</pre> 
</div>
</div>
<a id="a1d9468a998bf06bc173c376c642c6a0e" name="a1d9468a998bf06bc173c376c642c6a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9468a998bf06bc173c376c642c6a0e">&#9670;&nbsp;</a></span>get_liberties_for_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> set go_rules.GoRules.get_liberties_for_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Takes in a group and gets all of the liberties for this group. This is stored as a set so that pieces that are
beside each other and share the same liberty do not duplicate this liberty so that we don't end up getting extra
liberties for this group
:param group: group that we want to get all of the liberties for
:return: A set representing all of the liberties for the group. Will return a set of length 0 if the group has
no liberties
</pre> 
</div>
</div>
<a id="ac5bb26e3a1edf7fcf79f99909eceb7ee" name="ac5bb26e3a1edf7fcf79f99909eceb7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bb26e3a1edf7fcf79f99909eceb7ee">&#9670;&nbsp;</a></span>get_number_of_black_pieces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int go_rules.GoRules.get_number_of_black_pieces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">goes through the board and sums up the number of black pieces on the board
:param piece_matrix: state that you want to check for black pieces
:return: the number of black pieces on the board in this state
</pre> 
</div>
</div>
<a id="ad79efd9d2593b4686bccc7a47db17a76" name="ad79efd9d2593b4686bccc7a47db17a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79efd9d2593b4686bccc7a47db17a76">&#9670;&nbsp;</a></span>get_number_of_white_pieces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int go_rules.GoRules.get_number_of_white_pieces </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">goes through the board and sums up the number of white pieces on the board
:param piece_matrix: state that you want to check for white pieces
:return: the number of white pieces on the board in this state
</pre> 
</div>
</div>
<a id="aaee1d9a43fa27d7a39b82c2bc29a0817" name="aaee1d9a43fa27d7a39b82c2bc29a0817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee1d9a43fa27d7a39b82c2bc29a0817">&#9670;&nbsp;</a></span>get_piece_at_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpiece_1_1_piece.html">Piece</a> go_rules.GoRules.get_piece_at_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the piece at the given row and col. This may be an empty position and in that case the Piece returned
will have a colour of either Clear or Ko
:param row: row that we want to check
:param col: col that we want to check
:return: the Piece at that position
</pre> 
</div>
</div>
<a id="ae37549f7e9d885dc98eebfc1ce883fbb" name="ae37549f7e9d885dc98eebfc1ce883fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37549f7e9d885dc98eebfc1ce883fbb">&#9670;&nbsp;</a></span>get_territory_for_black()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int go_rules.GoRules.get_territory_for_black </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets territory for black by only counting empty spaces where at least two of the pieces beside it are also black
:param piece_matrix: the state that you want to check blacks territory for
:return: returns the amount of territory that black has as an integer
</pre> 
</div>
</div>
<a id="a4d485c4c0ba152ec1c223038dd3bba15" name="a4d485c4c0ba152ec1c223038dd3bba15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d485c4c0ba152ec1c223038dd3bba15">&#9670;&nbsp;</a></span>get_territory_for_white()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int go_rules.GoRules.get_territory_for_white </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets territory for white by only counting empty spaces where at least two of the pieces beside it are also white
:param piece_matrix: the state that you want to check whites territory for
:return: returns the amount of territory that white has as an integer
</pre> 
</div>
</div>
<a id="a00ab9e04a9c181f5bbd9f8a129135ebc" name="a00ab9e04a9c181f5bbd9f8a129135ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ab9e04a9c181f5bbd9f8a129135ebc">&#9670;&nbsp;</a></span>get_white_territory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int go_rules.GoRules.get_white_territory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Defining white territory as any empty spot that is fully surrounded by only white
</pre> 
</div>
</div>
<a id="af704796aa1a51d4f0b25f60fe54508ad" name="af704796aa1a51d4f0b25f60fe54508ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af704796aa1a51d4f0b25f60fe54508ad">&#9670;&nbsp;</a></span>is_move_legal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool go_rules.GoRules.is_move_legal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tuple&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcolours_1_1_colour.html">Colour</a>&#160;</td>
          <td class="paramname"><em>colour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classplayerturn_1_1_player_turn.html">PlayerTurn</a>&#160;</td>
          <td class="paramname"><em>current_colour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Takes in a position for a possible move to be played along with the colour of the piece that will be placed.
First creates a copy of the board so that it is able to check if the board is legal without having to update the
actual board position. It will then check if position has any liberties or if it is surrounded by pieces of the same
colour. If it is then it is a valid move. If not will remove any dead groups from the board and then checks to see
if the piece is still on the board to check if the piece placement was a valid capture or not. Also checks for Ko
to make sure that positions can not be repeated infinitely on the board
:param position: Position of where the piece will be placed
:param colour: Colour of the piece to be placed
:param current_colour: Whose turn it currently is
:return: True if the piece is legal, otherwise False
</pre> 
</div>
</div>
<a id="a69317b71d092cd0f364e40c14eda49a3" name="a69317b71d092cd0f364e40c14eda49a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69317b71d092cd0f364e40c14eda49a3">&#9670;&nbsp;</a></span>next_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def go_rules.GoRules.next_state </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Placed a black piece at the given position
:param piece_matrix: the state that you want to be updated
:param position: the position that you want to place the black piece at
:return: the new state with the black piece placed at the given position
</pre> 
</div>
</div>
<a id="ac5e91e0711894c1b78bd69180b835996" name="ac5e91e0711894c1b78bd69180b835996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e91e0711894c1b78bd69180b835996">&#9670;&nbsp;</a></span>remove_captured_groups_from_board()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def go_rules.GoRules.remove_captured_groups_from_board </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Removes all captured pieces in this state.
First removes all of the opponent pieces that have no liberties left and then removes all pieces of the current
colour that have no liberties left.
:param piece_matrix: The state that you want to remove all of the captured pieces from
:return: the new state that has any pieces that were captured removed
</pre> 
</div>
</div>
<a id="ac787ab5125c90e778d5486b1a2f323d1" name="ac787ab5125c90e778d5486b1a2f323d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac787ab5125c90e778d5486b1a2f323d1">&#9670;&nbsp;</a></span>score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int go_rules.GoRules.score </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>piece_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">returns an integer representation of how the game is approximately going
black will have a positive when they are winning and will return a negative value if white is winning
if 0 is returned then the game is fairly simple
the function is kept fairly simple as it will be called a lot inside of the minimax algorithm so needs to be
as fast as possible
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>E:/college/Project/Code/go_rules.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
